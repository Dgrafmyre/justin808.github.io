#+BEGIN_HTML
---
layout: post
title: "Saner Rails Logging"
date: 2013-04-29 17:41
comments: true
categories: 
keywords: 
description: 
published: false
---
#+END_HTML


TLDR: Clean logging and error handling is a critical aspect of a RoR app.


We can have an Rails app with great rspec tests, and then in production,
something goes wrong, and then the right error handling does not happen, making
a bad situation worse. By this, I mean, it's bad enough that something went
wrong in production. It's even worse if:
1. You don't have clear log messages that identify exactly what went wrong.
2. You didn't get automatically notified that something went wrong. Instead,
   the customer told the customer service that there's an issue. Ideally, the
   second an error happens, responsible developers should be notified.



   


Tip: Enable exception notification messages in development mode, and be sure to
enable [[http://mailcatcher.me/][MailCatcher]]. Be sure to check out this post on [[http://www.mikeperham.com/2012/12/09/12-gems-of-christmas-4-mailcatcher-and-mail_view/][MailCatcher and mail_view]].



* Figure out your strategy
1. Consider if you should re-throw the exception
2. Consider how the code is being invoked, such as from a call to generate
   HTML or an ajax request, or maybe a batch job. All of these cases have very
   different needs for how the error should be handled.
3. Test the logging of the exception in both development and production mode.
   You want to ensure that any exception prints clearly regardless of Rails
   environment.
   
4. Avoid rescuing/catching if you can't do anything with the exception. For
   example, in a model method, you might be calling that from a controller, but
   you also might be calling that from some scheduled job. Thus, it's hard to
   say what the right action should be.



1. If you can't do 





Log Rage seems great with one exception, I want to log the request parameters...



https://github.com/roidrage/lograge
https://github.com/roidrage/lograge/blob/master/README.md
http://www.paperplanes.de/2012/3/14/on-notifications-logsubscribers-and-bringing-sanity-to-rails-logging.html


http://ionrails.com/2013/03/26/how-to-add-the-request-parameters-along-with-full-url-request-in-lograge-outputted-files/



http://blog.rubybestpractices.com/posts/rklemme/003-The_Universe_between_begin_and_end.html

The tricky part about rescue is which exceptions to catch. If you cannot handle
an exception, you should not catch it because otherwise you will prevent other
code that is capable of handling it to work. Actually, as long as you do not
raise again, nobody outside will notice that there was an error in the first
place. A special case is raise without arguments: sometimes it is reasonable to
catch all exceptions, log the event and rethrow:



#+BEGIN_SRC ruby
  scenario "Purchase cart, strip", :vcr do
    error_content = "Testing error handling exception message in Stripe"
    PaymentGateway.stub(:charge) { raise Stripe::InvalidRequestError.new(error_content, 'id') }
    place_order "stripe-failure"
    should have_content error_content
    should have_content "Error purchasing"
    order.reload
    order.purchased.should_not be
  end

#+END_SRC



#+BEGIN_SRC ruby
  def validate_error_emailed
    email = ActionMailer::Base.deliveries.last
    email.should_not be_nil
    email.to.should_not include(order.user.email)
    email.to.should include('justin@blinkinc.com')
  end
#+END_SRC
