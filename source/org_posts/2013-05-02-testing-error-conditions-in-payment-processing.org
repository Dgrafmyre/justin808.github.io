#+BEGIN_HTML
---
layout: post
title: "Testing Error Conditions in Payment Processing"
date: 2013-05-02 00:01
comments: true
categories: 
keywords: 
published: false
description: 
---
#+END_HTML

Suppose you've created the super-duper Rails storefront application that takes
online payments. You may even have some unit tests that verify the code. Then
you get the dreaded call that customers are being charged twice and their
orders are not processed. WTF?

* Your Code Depends on Outside Systems (that Might Raise Errors)
It's not entirely obvious how to verify proper error handling when outside
systems fail, or even when odd errors are raised from your own code. Payment
processing deserves some special attention because it's a dependency on an
outside service (the payment processor) and will probably require updating
several tables. Once you process a payment, order fulfillment is next. You'll
probably be updating several tables, so you'll want to use a transaction to
ensure that all or nothing saves. While code review and manual testing are good
first steps, you should consider a few extra steps with error handling for
sensitive parts of your application.


* Verification of Error Handling Strategy
Typically, error handling code is not well tested. It's much more common to test
the "happy path" of everything going right.

Let's look at hypothetical example and some tests that can flush out some
errors.

#+BEGIN_SRC ruby
class Order
  def purchase_cart
    error_message = nil
    Order.transaction do
      # user has charge info, returns either error_message if failed or charge_details if success
      error_message, charge_details = PaymentGateway.charge user, total 
      set_charge_fields_and_save user, charge_details unless error_message # update the order to indicated purchased
      fulfill_order # do lots of complicated stuff to fulfill the order
    end
    error_message # return any error message if there is one
  end
end
#+END_SRC

* Payment Processing is Like a 2-Phase Commit
Payment processing like a 2-phase commit, except one has to handle all the
what-ifs to be sure that it's handled correctly.

In general, you want the whole processing of an order to take place within a
transaction. The steps are something like this:
  1. Connect to outside resource to make charge
  2. Update database records indicating charge successful
  3. Fulfill the order

Rails transactions work such than any exception in the block will cause the
transaction to be rolled back. The problem with the above code is what happens
if fulfill\_order throws an exception? The customer has been charged, the order
was updated to reflect payment, but then *ka-boom* and an exception is raised,
and any database updates to the order are rolled back, *but the payment is not
refunded*. The customer is confused as there is a charge but nothing else.

* Brute Force Methodology
You can simulate error conditions by manually placing =raise StandardError=
statements in your code, and then testing, say in the UI manually. This is a
good first step to verify that your error handling is working correctly.

For the above example, the different methods referenced, such as
=process\_order= can get modified with a single line at the beginning, which
would be:

#+BEGIN_SRC ruby
def process_order
  raise "Any error message"
  # Lots of other code that can be commented out
end
#+END_SRC

Then go into the UI and test placing an order. Consider the following questions:
1. Was the right error message displayed to the user?
2. Was the right information logged at the correct log level?
3. Was an automatic email sent regarding the error?

(Numbers 2 and 3 will be addressed in an upcoming article on error logging
setup.)

By applying this technique to each of the components of completing a purchase,
one can flush out (and handle) nearly all of the different possible errors that
could affect a purchase. Give this technique a try in some critical section of
the code. You'll be surprised how well it works.

* RSpec Testing of Errors 
It turns out that with stubbing in =rspec=, it's easy to test error handling!
[[https://www.relishapp.com/rspec/rspec-mocks/v/2-13/docs/method-stubs][RSpec provides a nice mocking library]]. The test code would look something like
this. Pay attention to the call to *stub*.

#+BEGIN_SRC ruby
describe Order do
  describe "#purchase_cart" do
    context "process_order fails" do
      let(:order) { create :order } # factory_girl creation of order and related objects
      before do
        Order.any_instance.stub(:fulfill_order) { raise ArgumentError, "test error" }
        PaymentGateway.should_receive(:charge).and_return([nil, "charge_details"])
        PaymentGateway.should_receive(:refund).and_return("refund_details")
      end
      it "should throw an error" do
        expect {
          order.purchase_cart
        }.to raise_error
        order.reload 
        order.purchased.should_not be   
        # charge refunded verified in mock
      end
    end
#+END_SRC

The main problem is that if fulfill\_order raises an exception, then the
customer is charged, yet due to the transaction, there's no record in the
database that any order took place.

Instead, what is needed is something like this:
#+BEGIN_SRC ruby
class Order
  def purchase_cart
    error_message = nil
    begin
      Order.transaction do
        # user has a credit card info, returns either error_message if failed or charge_details if success
        error_message, charge_details = PaymentGateway.charge user, total 
        set_charge_fields_and_save user, charge_details unless error_message # update the order to indicated purchased
      end
      fulfill_order # do lots of complicated stuff to process the order
    rescue => e
      Utility.log_exception e # Unified strategy for error handling including email notification
      refund_charge if charge_details
      throw e
    end
    error_message # return any error message if there is one
  end
end
#+END_SRC

Here are the key points to the improved code:
1. There's a block to catch the exception and properly handle the case of an a
   charge being made and needing to be refunded. =Utility.log_exception= can
   ensure that all the right things happen with this sort of error.
2. fulfill_order is moved outside of the transaction block. This allows the
   transaction to complete, and then the order\_fulfillment takes place. If
   there's an issue in fulfilling the order, that can be dealt with separately
   from the original charge. 
   
   
* RSpec Capybara Tests of UI Errors
It's possibly more important and sometimes easier to do the verification at the
integration level in RSpec feature specs using Capybara. The secret sauce is
the use of stubbing to replace some key methods such that they throw an
exception. This sort of technique works amazingly well.
I find that the best way to develop such a test is to:
1. Make sure you've got tests on the "happy" case where the script goes as
   planned.
2. Then introduce test cases where have bits of code like this that will raise
   an error at an opportune time.
   #+BEGIN_SRC ruby
     Order.any_instance.stub(:fulfill_order) { raise ArgumentError, "test error" }
   #+END_SRC 
3. Allow the test cases to fail, and put in screen shots (in Capybara with
   phantomjs, that looks like this:
   #+BEGIN_SRC ruby
   render_page "a-descriptive-name"
   #+END_SRC
   And you've got this method setup in a spec helper file:
   #+BEGIN_SRC ruby
   def render_page name
     path = File.join Rails.application.config.integration_test_render_dir, "#{name}.png"
     page.driver.render(path)
   end 
   #+END_SRC
4. Put in some assertions that the page shows the right error and the records
   in the database have the right values.
  




#+BEGIN_SRC ruby
  scenario "Purchase cart, strip", :vcr do
    error_content = "Testing error handling exception message in Stripe"
    PaymentGateway.stub(:charge) { raise Stripe::InvalidRequestError.new(error_content, 'id') }
    place_order "stripe-failure"
    should have_content error_content
    should have_content "Error purchasing"
    order.reload
    order.purchased.should_not be
  end

#+END_SRC



#+BEGIN_SRC ruby
  def validate_error_emailed
    email = ActionMailer::Base.deliveries.last
    email.should_not be_nil
    email.to.should_not include(order.user.email)
    email.to.should include('justin@blinkinc.com')
  end
#+END_SRC
