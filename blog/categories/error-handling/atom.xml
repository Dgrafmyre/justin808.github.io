<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Error Handling | Rails on Maui]]></title>
  <link href="http://www.railsonmaui.com//blog/categories/error-handling/atom.xml" rel="self"/>
  <link href="http://www.railsonmaui.com//"/>
  <updated>2013-05-27T22:10:11-10:00</updated>
  <id>http://www.railsonmaui.com//</id>
  <author>
    <name><![CDATA[Justin Gordon]]></name>
    <email><![CDATA[justin.gordon@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Testing Error Handling]]></title>
    <link href="http://www.railsonmaui.com//blog/2013/05/11/testing-error-handling/"/>
    <updated>2013-05-11T00:01:00-10:00</updated>
    <id>http://www.railsonmaui.com//blog/2013/05/11/testing-error-handling</id>
    <content type="html"><![CDATA[<p>
How do ensure that your application properly handles errors, especially when
relying on third parties, such as payment processors? Is it easy to verify that
the right things happen when the wrong things happen? Last week's article
<a href="http://www.railsonmaui.com/blog/2013/05/08/strategies-for-rails-logging-and-error-handling/">Strategies for Rails Logging and Error Handling</a> discussed some techniques to
setup a good error handling strategy. Here's some techniques to verify that your
application does what you expect it to do when things go wrong. The key message
is to check how your application handles errors, before your customers do.
</p>




<!-- more -->




<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Your Code Depends on Outside Systems (That Might Raise Errors)</h2>
<div class="outline-text-2" id="text-1">

<p>Suppose you've created the super-duper Rails storefront application that takes
online payments. You may even have some unit tests that verify the code. Then
you get the dreaded call that customers are being charged twice and their
orders are not processed. WTF?
</p>
<p>
It's not entirely obvious how to verify proper error handling when outside
systems fail, or even when odd errors are raised from your own code. Payment
processing deserves some special attention because it's a dependency on an
outside service (the payment processor) and will typically require database
updates based on the result of the payment processing. If you're updating
several tables, then you'll want to use a transaction to ensure that all or
nothing saves. While code review and manual testing are good first steps, you
should consider a few extra steps with error handling for sensitive parts of
your application.
</p>

</div>

</div>




<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Verification of Error Handling Strategy</h2>
<div class="outline-text-2" id="text-2">

<p>Typically, error handling code is not well tested. It's much more common to test
the "happy path" of everything going right.
</p>
<p>
Let's look at hypothetical example and some tests that can flush out some
errors.
</p>


{% codeblock lang:ruby %}
class Order
  def purchase_cart
    error_message = nil
    Order.transaction do
      # self.user record has charge info, and self.total is the order total
      # PaymentGateway.charge returns either error_message if failed or charge_details if success
      error_message, charge_details = PaymentGateway.charge user, total
      # update the order and the user records with the charge_details
      set_charge_fields_and_save user, charge_details unless error_message # update the order to indicated purchased
      fulfill_order # do lots of complicated stuff to fulfill the order
    end
    error_message # return any error message if there is one
  end
end
{% endcodeblock %}

<p>
So what can go wrong?
</p>
</div>

</div>




<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Payment Processing is Like a 2-Phase Commit</h2>
<div class="outline-text-2" id="text-3">

<p>Conceptually, you want a transaction, such that it's all or nothing. If the
charge goes through, then so does everything else. Payment processing like a
2-phase commit, except one has to handle all the what-ifs to be sure that it's
handled correctly.
</p>
<p>
The general steps of payment processing are like this:
</p><ol>
<li>Connect to outside resource to make charge.
</li>
<li>Update database records indicating charge successful.
</li>
<li>Fulfill the order.
</li>
</ol>


<p>
Rails transactions work such than any exception in the block will cause the
transaction to be rolled back. The problem with the above code is what happens
if fulfill_order throws an exception? The customer has been charged, the order
was updated to reflect payment, but then <b>ka-boom</b> and an exception is raised,
and any database updates to the order are rolled back, <b>but the payment is not refunded</b>. The customer is confused as there is a charge but nothing else. How
could you have tested (and avoided) this?
</p>
</div>

</div>




<div id="outline-container-4" class="outline-2">
<h2 id="sec-4">Brute Force Methodology</h2>
<div class="outline-text-2" id="text-4">

<p>You can simulate error conditions by manually placing =raise "any error message"=
statements in your code, and then testing, say in the UI manually. This is a
good first step to verify that your error handling is working correctly. You
might raise a specific error, if say your payment processor throws a specific
type of error.
</p>
<p>
For the above example, the different methods referenced, such as <code>process_order</code>
can get modified with a single line at the beginning, which would be:
</p>


{% codeblock lang:ruby %}
def process_order
  raise "Any error message"
  # Lots of other code that can be commented out
end
{% endcodeblock %}

<p>
Then go into the UI and test placing an order. Consider the following questions:
</p><ol>
<li>Was the right error message displayed to the user?
</li>
<li>Was the right information logged at the correct log level?
</li>
<li>Was an automatic email sent regarding the error?
</li>
</ol>


<p>
See my prior article <a href="http://www.railsonmaui.com/blog/2013/05/08/saner-rails-logging/">Saner Rails Logging</a> for the answers to #2 and #3.
</p>
<p>
By applying this technique to each of the components of completing a purchase,
one can flush out (and handle) nearly all of the different possible errors that
could affect a purchase. Give this technique a try in some critical section of
the code. You'll be surprised how well it works. Before giving you the fix to
the above code, let's see if we can write unit and feature tests on our error
handling.
</p>
</div>

</div>




<div id="outline-container-5" class="outline-2">
<h2 id="sec-5">RSpec Unit Testing of Errors</h2>
<div class="outline-text-2" id="text-5">

<p>It turns out that with stubbing in <code>rspec</code>, it's easy to test error handling!
<a href="https://www.relishapp.com/rspec/rspec-mocks/v/2-13/docs/method-stubs">RSpec provides a nice mocking library</a>. The test code would look something like
this. Pay attention to the call to <b>stub</b>.
</p>


{% codeblock lang:ruby %}
describe Order do
  describe "#purchase_cart" do
    context "process_order fails" do
      let(:order) { create :order } # factory_girl creation of order and related objects
      before do
        # The magic stubbing of every instance
        Order.any_instance.stub(:fulfill_order) { raise ArgumentError, "test error" }
        # The call to purchase_cart will first call 'charge'
        PaymentGateway.should_receive(:charge).and_return([nil, "charge_details"])
        # The error from within purchase_cart should do a refund
        PaymentGateway.should_receive(:refund).and_return("refund_details")
      end
      it "should throw an error" do
        expect {
          order.purchase_cart
        }.to raise_error
        order.reload
        order.purchased.should_not be
        # charge refunded verified in mock
      end
    end
{% endcodeblock %}

<p>
This test code ensures that the error handling of purchase_cart will catch an
error from fulfill_order, and properly refund the payment and rollback any
changes to the order record.
</p>
<p>
Here's an improved version of the Order#payment_method above:
{% codeblock lang:ruby %}
class Order
  def purchase_cart
    error_message = nil
    begin
      Order.transaction do
        # user has a credit card info, returns either error_message if failed or charge_details if success
        error_message, charge_details = PaymentGateway.charge user, total
        set_charge_fields_and_save user, charge_details unless error_message # update the order to indicated purchased
      end
      fulfill_order # do lots of complicated stuff to process the order, do this outside of the original tx, so that the payment info can be committed.
    rescue => e
      Utility.log_exception e # Unified strategy for error handling including email notification, see below
      refund_charge if charge_details # If there's an error here, then sys admins will have to manually refund the charge.
      throw e
    end
    error_message # return any error message if there is one
  end
end
{% endcodeblock %}

Here are the key points to the improved code:
</p>
<ol>
<li>There's a block to catch the exception which is <i>separate from the    transaction block</i>. The <code>rescue</code> properly handles the case of an a charge
   being made and needing to be refunded. <code>Utility.log_exception</code> will ensure
   that all the right things happen with this sort of error (see <a href="http://www.railsonmaui.com/blog/2013/05/08/saner-rails-logging/">code for Utlity.logException</a>).
</li>
<li>fulfill_order is moved outside of the transaction block. This allows the
   transaction to complete, and then the order_fulfillment takes place. If
   there's an issue in fulfilling the order, that can be dealt with separately
   from the original charge. In other words, the customer can successfully pay
   for the order, and the store can deal with the failure to fulfill the order.
</li>
</ol>


</div>

</div>




<div id="outline-container-6" class="outline-2">
<h2 id="sec-6">RSpec Capybara Feature (Integration) Tests of UI Errors</h2>
<div class="outline-text-2" id="text-6">

<p>It's possibly more important and sometimes easier to do the verification at the
integration level in RSpec feature specs using <a href="https://github.com/jnicklas/capybara">Capybara</a> with <a href="http://phantomjs.org/">PhantomJs</a> and
<a href="https://github.com/jonleighton/poltergeist">Poltergeist</a>. The secret sauce is the same use of the same stubbing technique as
above to replace some key methods such that they throw an exception. This sort
of technique works amazingly well to ensure that application will do the right
then when an unexpected failure occurs, from the logging and emailing of the
error message to the browser display to then end user.
</p>
<p>
I tend to develop such a test in an iterative manner:
</p><ol>
<li>Make sure you've got tests on the "happy" case where the story goes as
   planned.
</li>
<li>Then introduce test cases where have bits of code like this that will raise
   an error at an opportune time.
</li>
</ol>


{% codeblock lang:ruby %}
     Order.any_instance.stub(:fulfill_order) { raise ArgumentError, "test error" }
{% endcodeblock %}
<ol>
<li>Allow the test cases to fail, and put in screen shots (in Capybara with
   phantomjs, that looks like this:
</li>
</ol>


{% codeblock lang:ruby %}
   render_page "a-descriptive-name"
{% endcodeblock %}
<p>
   Setup this method <code>render_page</code> in a spec helper file like this:
{% codeblock lang:ruby %}
   def render_page name
     path = File.join Rails.application.config.integration_test_render_dir, "#{name}.png"
     page.driver.render(path)
   end
{% endcodeblock %}
</p><ol>
<li>Put in some assertions that the page shows the correct error and the records
   in the database have the right values.
</li>
<li>You can even
</li>
</ol>


<p>
Here's an example that tests a failure of the Stripe payment API, including
verification that an email was sent signifying an error:
</p>


{% codeblock lang:ruby %}
  # using gem vcr to record http communication for faster performance
  let(:order) { create :order } # lots of setup in factory girl for non-purchased order

  scenario "Purchase cart, Strip payment error", :vcr do
    # Setup the stub -- the secret sauce to this test
    error_content = "Testing error handling exception message"
    PaymentGateway.stub(:charge) { raise Stripe::InvalidRequestError.new(error_content, 'id') }
    place_order
    page.should have_content error_content
    page.should have_content "Error purchasing"
    order.reload
    order.purchased.should_not be
  end

  def place_order
   login_as(user, :scope => :user)
   visit shopping_cart_path
   page.should have_selector('.total .price', :text => in_dollars(order.total))
   page.render_page("purchase-cart-1")
   click_link "CHECKOUT"
   fill_in_credit_card_info # utility test method to fill in credit card data
   page.should have_selector('.total .price', :text => in_dollars(order.total))
   render_page("purchase-cart-with-payment-info-2")
   click_on "PURCHASE"
   wait_for_spinners # method to wait for the busy spinner to stop
   render_page("purchase-cart-after-click-purchase-3")
   validate_error_emailed
 end

 # example of how you verify that an error was emailed
 def validate_error_emailed
   email = ActionMailer::Base.deliveries.last
   email.should_not be_nil
   email.to.should_not include(order.user.email)
   email.to.should include('whoever@gets-error.com')
 end
{% endcodeblock %}

</div>

</div>




<div id="outline-container-7" class="outline-2">
<h2 id="sec-7">Conclusion</h2>
<div class="outline-text-2" id="text-7">

<p>If you aren't simulating how your application responds to errors, then you'll
eventually find out, and the result might not be as good as you'd prefer. You
can simulate errors with the very simple and quick technique of a well placed
=raise "some error"=, and then testing in a UI. Or you might prefer the
robustness of unit or feature tests using stubbing. Either way, the key message
is to check how your application handles errors, before your customers do.
</p>
<p>
Related Post:
<a href="http://www.railsonmaui.com/blog/2013/05/08/strategies-for-rails-logging-and-error-handling/">Strategies for Rails Logging and Error Handling</a>
</p></div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Strategies for Rails Logging and Error Handling]]></title>
    <link href="http://www.railsonmaui.com//blog/2013/05/08/strategies-for-rails-logging-and-error-handling/"/>
    <updated>2013-05-08T17:41:00-10:00</updated>
    <id>http://www.railsonmaui.com//blog/2013/05/08/strategies-for-rails-logging-and-error-handling</id>
    <content type="html"><![CDATA[<p>
TLDR: Clean logging and error handling is a critical aspect of a RoR app.
What's a good strategy? Why does this matter?
</p>


<p>
A Rails app can have awesome unit and functional tests, and then in production,
something goes wrong and the right error handling does not happen, making
a bad situation worse. By this, I mean, it's bad enough that something went
wrong in production. It's even worse if:
</p>


<ol>
<li>You don't have clear log messages that identify exactly what went wrong.
</li>
<li>You didn't get automatically notified via email that something went wrong.
   Instead, the customer told the customer service rep that there's an issue.
   Ideally, when an error happens, the responsible developers should be
   notified.
</li>
</ol>




<p>
Here's some tips on logging setup and error handling, including a utility
method to log the stack trace and send an email.
</p>


<p>
The next article,
<a href="http://www.railsonmaui.com/blog/2013/05/11/testing-error-handling/">Testing Error Handling</a>, will show you how to verify that your error handling strategy
is properly implemented, includind with rspec tests.
</p>




<!-- more -->




<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">Log Setup</h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1">Notification of any Exceptions via Email with Gem exception_notification</h3>
<div class="outline-text-3" id="text-1-1">

<p>Check out the gem <a href="http://smartinez87.github.io/exception_notification/">exception_notification</a>. It works great. One things the docs
don't point out is that it works great with <a href="http://mailcatcher.me/">MailCatcher</a>. This allows you to
"test" that your exception notification emails are being sent as expected
without using a real mail account. Thus, <i>do</i> enable exception logging in
development mode, contrary to the basic setup. Here's a config example at this
post on <a href="http://www.mikeperham.com/2012/12/09/12-gems-of-christmas-4-mailcatcher-and-mail_view/">MailCatcher and mail_view</a>.
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2">Log the Browser Details with Gem 'browser_details'</h3>
<div class="outline-text-3" id="text-1-2">

<p>The gem <a href="https://github.com/gshutler/browser_details">browser_details</a> will tell you what type of browser was used, which
can be very important when errors occur. I cracked up when I read this from the
gem info page: 
</p><blockquote>

<p>Have you ever had the conversation:
</p>
<p>
Your site doesn't work.
What browser are you using and do you have Javascript enabled?
</p>
<p>
What's a browser?
</p>
</blockquote>



</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3">Control Rails Log Verbosity with Gem lograge</h3>
<div class="outline-text-3" id="text-1-3">

<p>Sometimes too much of a good thing (log info) is a bad thing, and that's true
with Rails default logging. Check out the gem '<a href="https://github.com/roidrage/lograge">lograge</a>'. The big difference is
that a single request will take a single line. To quote the README, instead of
logs like this:
</p>


<pre class="example">Started GET "/" for 127.0.0.1 at 2012-03-10 14:28:14 +0100
Processing by HomeController#index as HTML
  Rendered text template within layouts/application (0.0ms)
  Rendered layouts/_assets.html.erb (2.0ms)
  Rendered layouts/_top.html.erb (2.6ms)
  Rendered layouts/_about.html.erb (0.3ms)
  Rendered layouts/_google_analytics.html.erb (0.4ms)
Completed 200 OK in 79ms (Views: 78.8ms | ActiveRecord: 0.0ms)
</pre>


<p>
After installing lograge, you'll have one line for the request:
</p>


<pre class="example">method=GET path=/jobs/833552.json format=json controller=jobs action=show status=200 duration=58.33 view=40.43 db=15.26
</pre>


<p>
The one issue with <code>lograge</code> is that the default configuration does not log
request parameters, which can be useful for debugging. This blog post, <a href="http://ionrails.com/2013/03/26/how-to-add-the-request-parameters-along-with-full-url-request-in-lograge-outputted-files/">How to add request parameters to lograge logs</a>, addresses that shortcoming.
</p>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4">Utility Method to Log Exceptions</h3>
<div class="outline-text-3" id="text-1-4">

<p>This sample method <code>Utility.log_exception</code> takes care of logging an exception along with sending out an
email notification.
</p>
<p>
Example of calling <code>Utility.log_exception</code>:
</p>


{% codeblock lang:ruby %}
def my_method_with_error foobar
  do_something_that_raises foobar
rescue => e # catches StandardError (don't use rescue Esception => e)
  Utility.log_exception e, info: "called do_something_that_raises wihh #{foobar}"
end
{% endcodeblock %}

<p>
Definition of <code>Utility.log_exception</code>:
</p>


{% codeblock lang:ruby %}
class Utility
  # Logs and emails exception
  # Optional args:
  # request: request Used for the ExceptionNotifier
  # info: "A descriptive messsage"
  def self.log_exception e, args
    extra_info = args[:info]

    Rails.logger.error extra_info if extra_info
    Rails.logger.error e.message
    st = e.backtrace.join("\n")
    Rails.logger.error st

    extra_info ||= "<NO DETAILS>"
    request = args[:request]
    env = request ? request.env : nil
    if env
      ExceptionNotifier::Notifier.exception_notification(env, e, :data => {:message => "Exception: #{extra_info}"}).deliver
    else
      ExceptionNotifier::Notifier.background_exception_notification(e, :data => {:message => "Exception: #{extra_info}"}).deliver
     end
  end
end
{% endcodeblock %}

</div>
</div>

</div>




<div id="outline-container-2" class="outline-2">
<h2 id="sec-2">Strategy: Error Handling and Logging</h2>
<div class="outline-text-2" id="text-2">

<ol>
<li>Avoid rescuing/catching if you can't do anything with the exception. For
   example, in a model method, you might be calling that from a controller, but
   you also might be calling that from some scheduled job. Thus, it's hard to
   say what the right action should be. A special case is calling <code>raise</code> without
   arguments: sometimes it is reasonable to catch all exceptions, logging the
   exception, and then re-raising it like it was never caught.
</li>
<li>If you catch an exception, consider if you should re-throw the exception
   because code at a different level will be able to handle the exception more
   properly.
</li>
<li>Consider how the code is being invoked, such as from a call to generate
   HTML or an ajax request, or maybe a batch job. All of these cases have very
   different needs for how the error should be handled.
</li>
<li>Be sure you understand the order of your rescue clauses matter. This article
   <a href="http://blog.rubybestpractices.com/posts/rklemme/003-The_Universe_between_begin_and_end.html">The Universe between <code>begin</code> and <code>end</code></a> provides a good explanation.
   Basically put the most specific exception types first and something like
   <code>rescue =&gt; e</code> last.
</li>
<li>Ruby does not support the concept of a "cause" with an exception. Thus, if
   you catch an exception and are going to rethrow a different exception, then
   it's important to log the stack of the original exception, or else that
   information will be lost.
</li>
<li>Test the logging of the exception in both development and production mode.
   You want to ensure that any exception prints clearly regardless of Rails
   environment.
</li>
<li>A good way to test error handling is to temporarily put in <code>raise    ArgumentError</code> (or whatever other error), and see how the exception is
   handled, both by the logger and the UI.
</li>
<li>The worst scenario is catching an exception and failing to log any messages.
   This can make troubleshooting a problem very tricky.
</li>
</ol>


</div>

</div>




<div id="outline-container-3" class="outline-2">
<h2 id="sec-3">Verification and Testing</h2>
<div class="outline-text-2" id="text-3">

<p>The next article,
<a href="http://www.railsonmaui.com/blog/2013/05/11/testing-error-handling/">Testing Error Handling</a>, will show you how to verify that your error handling strategy
is properly implemented, and how to add rspec unit and functional tests on error
handling.
</p>
</div>
</div>

]]></content>
  </entry>
  
</feed>
